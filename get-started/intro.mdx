---
title: "What is RisingWave?"
description: "RisingWave is an event stream processing platform for developers. It offers an unified experience for real-time data ingestion, stream processing, and low-latency serving."
---
import { Button } from '/snippets/button.mdx';

<Frame>
  <img src="/images/current/intro/architecture_20250127.png"/>
</Frame>

RisingWave simplifies the development of real-time data pipelines and applications. It is purpose-built to:

* Ingest millions of events per second from both streaming and batch data sources.
* Perform stream processing to join and analyze live data streams with historical tables.
* Persist data and serve ad-hoc queries with single-digit millisecond latency.
* Deliver fresh, consistent results to data lakes (e.g., Apache Iceberg) or any destination.

RisingWave provides both a Postgres-compatible SQL interface and a DataFrame-style Python interface.

<Button href="/docs/current/get-started">
Get Started
</Button>
<br/>

## Why is RisingWave special?
RisingWave stands apart from traditional stream processing systems due to its:

### PostgreSQL compatibility
Connect via the PostgreSQL wire protocol - using psql, JDBC, or any Postgres tool.
* **Seamless integration**: Works with a wide range of tools in the PostgreSQL ecosystem.
* **Expressive SQL**: Supports structured, semi-structured, and unstructured data using a rich, familiar SQL dialect.
* **No manual state tuning**: Eliminates the need for complex state management configurations.

### Zero disk architecture
All data lives in S3 (or equivalent), with local disk used only as a cache.
* **Optimized for complex queries**: Ensures high performance for stateful operations like joins and time windowing.
* **Fast failure recovery**: Recovers from system crashes within seconds.
* **Dynamic scaling**: Adjusts resources instantly to handle workload spikes.

## In what use cases does RisingWave excel?

RisingWave is particularly effective for the following use cases:

* **Streaming analytics**: Achieve sub-second data freshness in live dashboards, ideal for high-stakes scenarios like stock trading, sports betting, and IoT monitoring.
* **Event-driven applications**: Develop sophisticated monitoring and alerting systems for critical applications such as fraud and anomaly detection.
* **Real-time data enrichment**: Continuously ingest data from diverse sources, conduct real-time data enrichment, and efficiently deliver the results to downstream systems.
* **Feature engineering**: Transform batch and streaming data into features in your machine learning models using a unified codebase, ensuring seamless integration and consistency.

## Comparing RisingWave with other systems

RisingWave is not simply an "alternative" to any existing product, but it is often compared with stream processors, analytical databases, and operational databases.

### Stream processors

Stream processors like ksqlDB, Spark Structured Streaming, and Flink SQL are frequently compared to RisingWave. While these systems have their strengths, RisingWave offers an exceptionally simple, PostgreSQL-style user experience, and eliminates the need for manual state management. It excels in:

* Handling complex queries like joins, aggregations, and time windows with high performance.
* Transparent dynamic scaling, allowing for scaling in and out within seconds rather than minutes or hours.
* Instant failure recovery, where RisingWave recovers in seconds rather than minutes or hours.

Additionally, RisingWave greatly simplifies overall architecture, see [How does RisingWave simplify your event-driven architecture?](#how-does-risingwave-simplify-your-event-driven-architecture). However, compared to these stream processors, RisingWave does not offer low-level Java and Scala APIs, but compensates by offering various language UDFs and SDKs.

### Analytical databases

Modern analytical databases, such as ClickHouse with materialized views, Snowflake with dynamic tables, BigQuery with continuous queries, and Databricks with Delta Live Tables, offer continuous processing capabilities. RisingWave surpasses these solutions in continuous processing by:

* Offering a rich feature set for stream processing, including time windowing, watermarks, and more.
* Being particularly optimized for handling complex streaming joins.
* Allowing data ingestion from and delivery to any system, without locking you into a specific ecosystem.

Moreover, RisingWaveâ€™s transparent dynamic scaling and instant failure recovery mechanisms are superior to other analytical databases.

However, RisingWave does not feature columnar storage. If your workloads mostly involve ad-hoc, long-range scans rather than predefined queries, an analytical database might be a better fit.

### Operational databases

RisingWave is PostgreSQL wire-compatible, enabling seamless integration with most tools in the PostgreSQL ecosystem. RisingWave is designed specifically for storing and processing streaming data, making it particularly well-suited for managing metrics and events rather than transactional data.

Note that RisingWave does not use the PostgreSQL engine internally, which results in certain PostgreSQL tools not being supported. Additionally, RisingWave does not support read-write transactions.

## How does RisingWave simplify your event-driven architecture?

RisingWave aims to help simplify event-driven architecture. You can think of RisingWave as a unified system that combines event streaming, stream processing, storage, and serving capabilities. Developers can express intricate stream-processing logic through cascaded materialized views. Additionally, it allows users to persist data directly within the system, eliminating the need to deliver results to external databases for storage and query serving.

<Frame>
  <img src="/images/current/intro/stream_processing_with_and_without_rw.jpeg"/>
</Frame>
<br/>
<CardGroup>
  <Card title="See the architecture" icon="sitemap" iconType= "solid" href="/reference/architecture" horizontal/>
  <Card title="Access the source code" icon="code" iconType= "solid" href="https://github.com/risingwavelabs/risingwave" horizontal/>
</CardGroup>




